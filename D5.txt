DSA PROBLEMS DAY - 5
---------------------------------------------------------------------------------------------------
//ABBA 

class ABBA:
    def _canObtain(self, target, index_end, reversed_end):
        while True:
            # Try first move
            try:
                if target[index_end] == 'A':
                    index_end += 1
                    continue
            except IndexError:
                pass

            # Try second move
            try:
                target = target[::-1]
                tmp_a = index_end
                index_end = reversed_end
                reversed_end = tmp_a

                if target[index_end] == 'B':
                    index_end += 1
                    continue
                else:
                    return False
            except IndexError:
                pass

            return True

    def canObtain(self, initial, target):
        # Try starting with the first move
        index_start = 0

        while True:
            index_start = target.find(initial, index_start)
            index_end = len(initial) + index_start
            reversed_start = len(target) - index_end - 1
            reversed_end = len(initial) + reversed_start
            
            if index_start == -1:
                break

            if self._canObtain(target, index_end, reversed_end):
                return 'Possible'
            
            index_start += 1

        # Try starting with the second move (reversed)
        reversed_target = target[::-1]
        reversed_start = 0
            
        while True:
            reversed_start = reversed_target.find(initial, reversed_start)
            reversed_end = len(initial) + reversed_start
            index_start = len(target) - reversed_end - 1
            index_end = len(initial) + index_start

            if reversed_start == -1:
                break

            if self._canObtain(target, index_end, reversed_end):
                return 'Possible'

            reversed_start += 1
        
        return 'Impossible'

------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
Q2 /// A Board Game

public class ABoardGame {
    private static final String ALICE = "Alice";
    private static final String BOB = "Bob";
    private static final String DRAW = "Draw";

    public String whoWins(String[] board) {
        int bLen = board.length-1;
        int region = bLen/2;

        while(region >= 0) {
            int bCount = 0;
            int aCount = 0;
            // top row, left to right
            for(int i=region; i<bLen-region; i++) {
                if(board[region].charAt(i) == 'A') aCount++;
                else if(board[region].charAt(i) == 'B') bCount++;
            }
            // right column, top to bottom
            for(int i=region; i<bLen-region; i++) {
                if(board[i].charAt(bLen-region) == 'A') aCount++;
                else if(board[i].charAt(bLen-region) == 'B') bCount++;
            }
            // bottom row, right to left
            for(int i=bLen-region; i>region; i--) {
                if(board[bLen-region].charAt(i) == 'A') aCount++;
                else if(board[bLen-region].charAt(i) == 'B') bCount++;
            }
            // left column, bottom to top
            for(int i=bLen-region; i>region; i--) {
                if(board[i].charAt(region) == 'A') aCount++;
                else if(board[i].charAt(region) == 'B') bCount++;
                System.out.println(Runtime.getRuntime().totalMemory());
            }

            if(aCount > bCount) return ALICE;
            else if(aCount < bCount) return BOB;
            else region--;
                System.out.println(Runtime.getRuntime().totalMemory());
        }
                System.out.println(Runtime.getRuntime().freeMemory());

        return DRAW;
    }


    public static void main(String[] args) {
        String[] board = {
                "BBB..BAB...B.B",
                ".AAAAAAAAAAAA.",
                "AA.AA.AB..A.AB",
                "..........B.AB",
                ".A..BBAB.A.BAB",
                ".AB.B.......A.",
                ".A..A.AB.A..AB",
                ".ABAA.BA...BA.",
                "BAAAB.....ABA.",
                ".A....B..A..B.",
                "B...B....B..A.",
                "BA.B..A.ABA.A.",
                "BAAAA.AAAAA.A.",
                "B.B.B.BB.B...."
        };

        String res = new ABoardGame().whoWins(board);
        System.out.println(res);
    }
}

------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

Q3/// ABBA DIV...

import java.util.HashSet;
import java.util.Set;


public class ABBADiv1 {

    private static final String FAIL = "Impossible";
    private static final String PASS = "Possible";

    private static String canObtain(String initial, String target) {
        int len = target.length();
        Set<String> temp = new HashSet<>();
        temp.add(target);

        while(initial.length() != len) {
            Set<String> nTemp = new HashSet<>();
            for(String t : temp) {
                if(t.endsWith("A")) nTemp.add(t.substring(0,t.length()-1));
                if(t.startsWith("B")) nTemp.add(reverse(t.substring(1)));
            }
            len--;

            temp.clear();
            temp.addAll(nTemp);
        }

        if(temp.contains(initial)) return PASS;
        else return FAIL;
    }

    private static String reverse(String initial) {
        int len = initial.length();
        char[] arr = initial.toCharArray();
        for(int i=0; i<len/2; i++) {
            char temp = arr[i];
            arr[i] = arr[len-i-1];
            arr[len-i-1] = temp;
        }
        return String.valueOf(arr);
    }

    public static void main(String[] args) {
        System.out.println("Test0: " + canObtain("A", "BABA"));
        System.out.println("Test1: " + canObtain("BAAAAABAA", "BAABAAAAAB"));
        System.out.println("Test2: " + canObtain("A", "ABBA"));
        System.out.println("Test3: " + canObtain("AAABBAABB", "BAABAAABAABAABBBAAAAAABBAABBBBBBBABB"));
        System.out.println("Test4: " + canObtain("AAABAAABB", "BAABAAABAABAABBBAAAAAABBAABBBBBBBABB"));
        System.out.println("Test5:" + canObtain("B","BBBBB"));
        System.out.println("Test6: " + canObtain("BA","ABB"));
    }
}

------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
// Q4 DYNAMIC ARRAY

package com.samuelale.practice;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Scanner;

/**
 * https://www.hackerrank.com/challenges/dynamic-array
 */
public class DynamicArray {

    public static void main(String[] args) {
        Scanner s = new Scanner(System.in);
        int N = s.nextInt();
        int Q = s.nextInt();

        Map<Integer, List<Integer>> seqList = new HashMap<>();
        int lastAns = 0;

        for(int q=0; q<Q; q++) {
            int qType = s.nextInt();
            int x = s.nextInt();
            int y = s.nextInt();
            int idx = (x ^ lastAns) % N;
            seqList.putIfAbsent(idx, new ArrayList<>());
            List<Integer> seq = seqList.get(idx);
            if(qType == 1) {
                seq.add(y);
            } else {
                lastAns = seq.get(y % seq.size());
                System.out.println(lastAns);
            }
        }
    }
}

------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

Q5 // a new hope 

using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

    public class ANewHope
    {
        public int count(int[] firstWeek, int[] lastWeek, int D)
        {
            bool isPassing = true;
            for (int i = 0; i < firstWeek.Length; i++)
            {
                if (firstWeek[i] != lastWeek[i])
                    isPassing = false;
            }
            if (isPassing)
                return 1;

            int skip = firstWeek.Length - D;

            int output = 0;
            for (int i = 1; i < firstWeek.Length+1; i++)
            {
                int currentSteps = Convert.ToInt32(Math.Ceiling((0.0 + (firstWeek.ToList().IndexOf(i) - lastWeek.ToList().IndexOf(i))) / (0.0 + skip)));
                if (currentSteps > output)
                    output = currentSteps;
            }

            return output+1;
        }
    }


------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------


























































